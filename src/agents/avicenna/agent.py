"""
Avicenna Agent for Aurora Sun V1.

Main agent class that orchestrates quality observation:
- Loads architecture spec from YAML
- Provides @avicenna_tracked decorator for message handlers
- Generates health reports
- Coordinates tracker and alert system

Philosophy: Diagnose, never fix. Human decides.

Reference: ARCHITECTURE.md Section 6 (Avicenna Agent)
"""

from __future__ import annotations

import functools
import logging
import time
from collections.abc import Awaitable, Callable
from dataclasses import dataclass, field
from datetime import UTC, datetime
from pathlib import Path
from typing import Any, TypeVar

from .alerts import AlertSeverity, AlertSystem
from .spec import SpecManager
from .tracker import Issue, IssueSeverity, StateTracker

logger = logging.getLogger(__name__)

F = TypeVar("F", bound=Callable[..., Awaitable[Any]])


# =============================================================================
# Health Report
# =============================================================================


@dataclass
class HealthReport:
    """System health report generated by Avicenna.

    Attributes:
        generated_at: When the report was generated.
        status: Overall system status (healthy/degraded/critical).
        active_sessions: Number of active tracked sessions.
        critical_issues: Number of critical issues in the buffer.
        warning_issues: Number of warning issues in the buffer.
        info_issues: Number of info issues in the buffer.
        stuck_states: List of stuck state descriptions.
        stale_interactions: List of stale interaction descriptions.
        recent_issues: Most recent issues for review.
        pending_alerts: Number of unsent alerts.
    """

    generated_at: datetime
    status: str  # "healthy", "degraded", "critical"
    active_sessions: int
    critical_issues: int
    warning_issues: int
    info_issues: int
    stuck_states: list[str] = field(default_factory=list)
    stale_interactions: list[str] = field(default_factory=list)
    recent_issues: list[dict[str, Any]] = field(default_factory=list)
    pending_alerts: int = 0


# =============================================================================
# Avicenna Agent
# =============================================================================


class AvicennaAgent:
    """Quality Observer Agent.

    Monitors system behavior against the architecture specification.
    Detects issues but never fixes them -- that is the admin's job.

    Usage:
        avicenna = AvicennaAgent()
        avicenna.load_spec()  # or avicenna.load_spec(path)

        # Track a transition
        issues = avicenna.track_transition(
            user_id=1, module="planning",
            from_state=None, to_state="SCOPE"
        )

        # Check system health
        report = await avicenna.get_health_report()

        # Decorate a handler
        @avicenna.tracked("planning")
        async def handle_planning(user_id, message):
            ...
    """

    def __init__(
        self,
        cooldown_seconds: int = 60,
        admin_chat_id: int | None = None,
    ) -> None:
        """Initialize Avicenna agent.

        Args:
            cooldown_seconds: Alert cooldown in seconds.
            admin_chat_id: Telegram chat ID for admin notifications.
        """
        self._spec = SpecManager()
        self._tracker: StateTracker | None = None
        self._alerts = AlertSystem(
            cooldown_seconds=cooldown_seconds,
            admin_chat_id=admin_chat_id,
        )
        self._initialized = False

    @property
    def is_initialized(self) -> bool:
        """Whether the agent has been initialized with a spec."""
        return self._initialized

    @property
    def spec(self) -> SpecManager:
        """Access the spec manager."""
        return self._spec

    @property
    def tracker(self) -> StateTracker:
        """Access the state tracker.

        Raises:
            RuntimeError: If the agent has not been initialized.
        """
        if self._tracker is None:
            raise RuntimeError(
                "AvicennaAgent not initialized. Call load_spec() first."
            )
        return self._tracker

    @property
    def alerts(self) -> AlertSystem:
        """Access the alert system."""
        return self._alerts

    def load_spec(self, spec_path: str | Path | None = None) -> None:
        """Load the architecture spec and initialize the tracker.

        Args:
            spec_path: Path to avicenna_spec.yaml. Uses default if None.
        """
        self._spec.load_spec(spec_path)
        self._tracker = StateTracker(self._spec)
        self._initialized = True
        logger.info("avicenna_agent_initialized")

    def load_spec_from_dict(self, data: dict[str, Any]) -> None:
        """Load spec from a dictionary (useful for testing).

        Args:
            data: Spec data in avicenna_spec.yaml format.
        """
        self._spec.load_from_dict(data)
        self._tracker = StateTracker(self._spec)
        self._initialized = True

    # -------------------------------------------------------------------------
    # Core Methods
    # -------------------------------------------------------------------------

    def track_transition(
        self,
        user_id: int,
        module: str,
        from_state: str | None,
        to_state: str | None,
    ) -> list[Issue]:
        """Track a state transition and create alerts for critical issues.

        Args:
            user_id: User performing the transition.
            module: Module name.
            from_state: Source state (None for entry).
            to_state: Target state (None for exit).

        Returns:
            List of issues detected.
        """
        issues = self.tracker.track_transition(
            user_id=user_id,
            module=module,
            from_state=from_state,
            to_state=to_state,
        )

        # Create alerts for critical issues
        for issue in issues:
            if issue.severity == IssueSeverity.CRITICAL:
                self._alerts.create_alert(
                    severity=AlertSeverity.CRITICAL,
                    title=f"[{issue.issue_type}] {issue.module}",
                    message=issue.description,
                    module=issue.module,
                )

        return issues

    def validate_transition(
        self,
        module: str,
        from_state: str | None,
        to_state: str | None,
    ) -> bool:
        """Check if a transition is valid without tracking it.

        Args:
            module: Module name.
            from_state: Source state.
            to_state: Target state.

        Returns:
            True if the transition is valid per the spec.
        """
        return self._spec.is_valid_transition(module, from_state, to_state)

    def detect_stuck_state(
        self,
        user_id: int,
        module: str,
        threshold_minutes: int | None = None,
    ) -> bool:
        """Check if a specific user is stuck in a module.

        Args:
            user_id: User to check.
            module: Module to check.
            threshold_minutes: Override threshold.

        Returns:
            True if the user is stuck.
        """
        stuck_issues = self.tracker.check_stuck_states(threshold_minutes)
        return any(
            i.user_id == user_id and i.module == module
            for i in stuck_issues
        )

    async def check_health(self) -> str:
        """Run all health checks and return overall status.

        Returns:
            Status string: "healthy", "degraded", or "critical".
        """
        # Check for stuck states
        stuck = self.tracker.check_stuck_states()
        stale = self.tracker.check_stale_interactions()

        # Create alerts for stuck states
        for issue in stuck:
            self._alerts.create_alert(
                severity=AlertSeverity.CRITICAL,
                title=f"[stuck_state] {issue.module}",
                message=issue.description,
                module=issue.module,
            )

        # Create alerts for stale interactions
        for issue in stale:
            self._alerts.create_alert(
                severity=AlertSeverity.WARNING,
                title=f"[stale_interaction] {issue.module}",
                message=issue.description,
                module=issue.module,
            )

        # Send pending alerts
        for alert in self._alerts.get_pending_alerts():
            await self._alerts.send_alert(alert)

        # Determine overall status
        critical_count = self.tracker.issue_buffer.get_critical_count()
        if critical_count > 0:
            return "critical"
        elif len(stale) > 0:
            return "degraded"
        else:
            return "healthy"

    async def get_health_report(self) -> HealthReport:
        """Generate a comprehensive health report.

        Returns:
            HealthReport with current system status.
        """
        status = await self.check_health()

        # Gather metrics
        active_sessions = self.tracker.get_active_sessions()
        buffer = self.tracker.issue_buffer

        critical_issues = buffer.get_critical_count()
        warning_issues = buffer.get_warning_count()
        info_count = len(buffer.get_issues(severity=IssueSeverity.INFO))

        # Get stuck state descriptions
        stuck_issues = buffer.get_issues(severity=IssueSeverity.CRITICAL)
        stuck_descs = [
            i.description for i in stuck_issues
            if i.issue_type == "stuck_state"
        ]

        # Get stale interaction descriptions
        stale_issues = buffer.get_issues(severity=IssueSeverity.WARNING)
        stale_descs = [
            i.description for i in stale_issues
            if i.issue_type == "stale_interaction"
        ]

        # Recent issues (last 20)
        recent = buffer.get_issues(limit=20)
        recent_dicts: list[dict[str, Any]] = [
            {
                "severity": i.severity.value,
                "type": i.issue_type,
                "module": i.module,
                "description": i.description,
                "timestamp": i.timestamp.isoformat(),
                "user_id": i.user_id,
            }
            for i in recent
        ]

        pending_alerts = len(self._alerts.get_pending_alerts())

        return HealthReport(
            generated_at=datetime.now(UTC),
            status=status,
            active_sessions=len(active_sessions),
            critical_issues=critical_issues,
            warning_issues=warning_issues,
            info_issues=info_count,
            stuck_states=stuck_descs,
            stale_interactions=stale_descs,
            recent_issues=recent_dicts,
            pending_alerts=pending_alerts,
        )

    # -------------------------------------------------------------------------
    # Decorator
    # -------------------------------------------------------------------------

    def tracked(self, module: str) -> Callable[[F], F]:
        """Decorator to track message handler execution.

        Tracks response time and records interactions for the specified module.
        Does NOT modify handler behavior -- only observes.

        Args:
            module: Module name for tracking.

        Returns:
            Decorator function.

        Usage:
            @avicenna.tracked("planning")
            async def handle_planning(user_id: int, message: str) -> str:
                ...
        """
        def decorator(func: F) -> F:
            @functools.wraps(func)
            async def wrapper(*args: Any, **kwargs: Any) -> Any:
                start_time = time.monotonic()

                # Extract user_id from kwargs or first positional arg
                user_id: int | None = kwargs.get("user_id")
                if user_id is None and len(args) > 0 and isinstance(args[0], int):
                    user_id = args[0]

                try:
                    result = await func(*args, **kwargs)

                    # Record interaction
                    if user_id is not None:
                        self.tracker.record_interaction(user_id, module)

                    # Check response time
                    elapsed = time.monotonic() - start_time
                    sla = self._spec.get_sla()
                    if elapsed > sla.max_response_time_seconds:
                        issue = Issue(
                            severity=IssueSeverity.WARNING,
                            issue_type="slow_response",
                            module=module,
                            description=(
                                f"Response took {elapsed:.1f}s "
                                f"(SLA: {sla.max_response_time_seconds}s)"
                            ),
                            user_id=user_id,
                            details={
                                "elapsed_seconds": round(elapsed, 2),
                                "threshold_seconds": sla.max_response_time_seconds,
                            },
                        )
                        self.tracker.issue_buffer.add(issue)

                    return result

                except Exception as exc:  # Intentional catch-all: observer must track any module crash before re-raising
                    # Track module crash
                    issue = Issue(
                        severity=IssueSeverity.CRITICAL,
                        issue_type="module_crash",
                        module=module,
                        description=f"Unhandled exception: {type(exc).__name__}: {exc}",
                        user_id=user_id,
                        details={
                            "exception_type": type(exc).__name__,
                            "exception_message": str(exc),
                        },
                    )
                    self.tracker.issue_buffer.add(issue)

                    # Create alert for crash
                    self._alerts.create_alert(
                        severity=AlertSeverity.CRITICAL,
                        title=f"[module_crash] {module}",
                        message=issue.description,
                        module=module,
                    )

                    raise  # Re-raise -- diagnose, never fix

            return wrapper  # type: ignore[return-value]
        return decorator
